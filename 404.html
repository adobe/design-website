<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Page Not Found</title>
  <script>window.location.pathname.includes('/jobs/') ? (window.location = '/jobs/?job=404'): null;</script>
  <script src="/scripts/scripts.js" type="module" crossorigin="use-credentials"></script>
  <link rel="stylesheet" href="/styles/styles.css"/>
  <link rel="icon" href="/favicon.ico" sizes="any">
  <link rel="icon" href="/icon.svg" type="image/svg+xml">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <script src="https://assets.adobedtm.com/a7d65461e54e/9ee19a80de10/launch-882c01867cbb.min.js" async></script>
  <style>
    html {
      height: 100%;
    }
    
    body {
      min-height: 100%;
      display: grid;
      grid-template-rows: auto;
      margin: 0;
      font-family: adobe-clean, helvetica, sans-serif;
      color: white;
      background-image: 
      linear-gradient(180deg, rgba(250 203 177 / 0%) 0%, rgba(250 203 177 / 0%) 30%, rgba(250 203 177 / 25%) 40%, rgba(250 203 177 / 60%) 50%, rgba(250 203 177 / 60%) 60%, rgba(250 203 177 / 25%) 70%, rgba(250 203 177 / 0%) 80%, rgba(250 203 177 / 0%) 100%), /*white*/
      radial-gradient(circle at 90% 50%, rgba(251 59 34 / 100%) 0%, rgba(251 59 34 / 100%) 20%, rgba(251 59 34 / 0%) 60%), /*red*/
      radial-gradient(circle at right 20%, rgba(71 187 106 / 100%) 0%, rgba(71 187 106 / 100%) 10%, rgba(71 187 106 / 0%) 40%), /*green*/
      radial-gradient(circle at -10% 50%, rgba(255 187 11 / 100%) 0%, rgba(255 187 11 / 50%) 5%, rgba(255 187 11 / 0%) 50%), /*yellow*/
      radial-gradient(circle at 5% top, rgba(39 11 156 / 100%) 0%, rgba(39 11 156 / 100%) 10%, rgba(39 11 156 / 50%) 25%, rgba(39 11 156 / 0%) 50%), /*blue*/
      radial-gradient(circle at 0% 40%, rgba(255 187 11 / 100%) 0%, rgba(255 187 11 / 100%) 5%, rgba(255 187 11 / 50%) 20%, rgba(255 187 11 / 0%) 30%), /*yellow*/
      radial-gradient(circle at right 70%, rgba(71 187 106 / 100%) 0%, rgba(71 187 106 / 100%) 10%, rgba(71 187 106 / 0%) 30%), /*green*/
      radial-gradient(circle at 20% bottom, rgba(39 11 156 / 100%) 10%, rgba(39 11 156 / 50%) 25%, rgba(39 11 156 / 0%) 50%), /*blue*/
      radial-gradient(circle at right bottom, rgba(0 169 188 / 100%) 0%, rgba(0 169 188 / 100%) 20%, rgba(0 169 188 / 0%) 40%), /*cyan*/
      radial-gradient(circle at right top, rgba(0 169 188 / 100%) 0%, rgba(0 169 188 / 100%) 20%, rgba(0 169 188 / 0%) 40%),  /*cyan*/
      linear-gradient(#ffb90b, #ffb90b);
      background-size: 100% 300% !important; /*needed to override cover*/
      background-attachment: fixed;
      user-select: none;
    }

    footer {
      grid-row-start: 3;
      grid-row-end: 4;
    }

    #playCanvas{
        position: absolute;
        width: 100%;
        height: 100%;
        z-index: 100;
    }
    
    canvas {
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    a {
      color: white;
    }
    
    .wrapper {
      --content-width: 90%;
      --layout-max-width-desktop: 102.6875em;
      margin: 0 auto;
      padding: 0;
      width: var(--content-width);
      max-width: var(--layout-max-width-desktop);
    }
    
    .container {
      display: grid;
      padding: 10rem 0 10rem;
      grid-template-columns: repeat(6, [col-start] 1fr);
      column-gap: 12px;
    }
    
    h1 {
      grid-column: col-start 1 / -2;
      padding-left: 1.875rem;
      margin-bottom: 2rem;

      font-family: "adobe-clean", adobe-clean, helvetica, arial, sans-serif;
      font-weight: 900;
      font-size: 2.5rem;
      line-height: 0.95;
      z-index: 101;
    }

    h2 {
      font-family: "adobe-clean-serif", adobe-clean-serif, georgia, serif;
      font-weight: 400;
      font-size: 1.25rem;
      line-height: 1.3;
      
      grid-column: col-start 1 / -2;
      padding-left: 1.875rem;
      z-index: 101;
    }

    @media (min-width: 900px) {
      .container {
        padding: 10rem 0 40rem;
        grid-template-columns: repeat(12, [col-start] 1fr);
      }

      h1 {
        font-size: 5.625rem;
        grid-column: col-start 2 / span 8;
      }
      
      h2 {
        font-size: 1.875rem;
        grid-column: col-start 2 / span 6;
      }
    }
  </style>
</head>
<body>
  <header></header>
  <main>
    <canvas id="playCanvas"></canvas>
    <div class="wrapper">
      <section class="container">
        <h1>Looks like we dropped the ball...</h1>
        <h2>Because that page doesn't exist. Play ball or bounce on over to <a href="/">our home page</a>.</h2>
      </section>
    </div>
  </main>
  <footer></footer>
  <script>

  /**
   * tween class
   */
  class Tween {

  EasingFunctions = {
      linear: (t) => t,
      // accelerating from zero velocity
      easeInQuad: (t) => t*t,
      // decelerating to zero velocity
      easeOutQuad: (t) => t*(2-t),
      // acceleration until halfway, then deceleration
      easeInOutQuad: (t) => t<.5 ? 2*t*t : -1+(4-2*t)*t,
      // accelerating from zero velocity 
      easeInCubic: (t) => t*t*t,
      // decelerating to zero velocity 
      easeOutCubic: (t) => (--t)*t*t+1,
      // acceleration until halfway, then deceleration 
      easeInOutCubic: (t) => t<.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1,
      // accelerating from zero velocity 
      easeInQuart: (t) => t*t*t*t,
      // decelerating to zero velocity 
      easeOutQuart: (t) => 1-(--t)*t*t*t,
      // acceleration until halfway, then deceleration
      easeInOutQuart: (t) => t<.5 ? 8*t*t*t*t : 1-8*(--t)*t*t*t,
      // accelerating from zero velocity
      easeInQuint: (t) => t*t*t*t*t,
      // decelerating to zero velocity
      easeOutQuint: (t) => 1+(--t)*t*t*t*t,
      // acceleration until halfway, then deceleration 
      easeInOutQuint: (t) => t<.5 ? 16*t*t*t*t*t : 1+16*(--t)*t*t*t*t,
      // bounce out
      bounceOut: (t) => {
          if (t < (1/2.75)) {
              return (7.5625*t*t) ;
          } else if (t < (2/2.75)) {
              return (7.5625*(t-=(1.5/2.75))*t + .75);
          } else if (t < (2.5/2.75)) {
              return (7.5625*(t-=(2.25/2.75))*t + .9375);
          } else {
              return (7.5625*(t-=(2.625/2.75))*t + .984375);
          }
      }
  }

  _id = Math.floor(Math.random() * 1000);
  _startTime = Date.now();
  _target = null;
  _duration = 0;
  _delay = 0;
  _easingFunction = this.EasingFunctions.linear;
  _startVars = {};
  _endVars = {};
  _hasSetStartVars = false;
  completed = false;

  constructor(target, vars) {
      this._target = target;
      this._delay = vars.delay ? vars.delay * 1000 : 0; //to milli
      this._duration = vars.duration * 1000; //to milli
      this._startTime = Date.now() + this._delay;
      if (vars.ease && this.EasingFunctions[vars.ease]) {
          this._easingFunction = this.EasingFunctions[vars.ease];
      }

      for (let i in vars) {
          if (target.hasOwnProperty(i)) {
              this._startVars[i] = target[i];
              this._endVars[i] = vars[i];
          }
      }
  }

  //set start vars from current value.
  setStartVars() {
      if (this._hasSetStartVars) {
          return;
      }

      this._hasSetStartVars = true;
      for (let i in this._endVars) {
          if (this._target.hasOwnProperty(i)) {
              this._startVars[i] = this._target[i];
          }
      }
  }

  update() {
      if (Date.now() - this._startTime < 0) { //if delay now may be less than start time
          return;
      }

      this.setStartVars();

      let elapsed = (Date.now() - this._startTime) / this._duration;
      elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;

      let easeTime = this._easingFunction(elapsed);

      for (let i in this._endVars) {
          this._target[i] = this.lerp(this._startVars[i], this._endVars[i], easeTime);
      }

      if (elapsed == 1) {
          this.completed = true;
      }
  }

  /**
   * Linear interpolation
   * @param v0 start value
   * @param v1 end value
   * @param t time 
   * @returns number
   */
  lerp = (v0, v1, t) => {
      return v0 * (1 - t) + v1 * t;
  };
  }

  /**
  * Tween Manager class
  */
  class Tw {

  static tweens = [];

  static to(target, vars) {
      let tw = new Tween(target, vars);
      this.tweens.push(tw);
  }

  static set(target, vars) {
      for (let i in vars) {
          if (target.hasOwnProperty(i)) {
              target[i] = vars[i];
          }
      }
  }

  static fromTo(target, fromVars, toVars) {
      this.set(target, fromVars);
      this.to(target, toVars);
  }

  static update() {
      let i = this.tweens.length;
      while (i-- ) {
          const tween = this.tweens[i];
          if (tween.completed) {
              this.tweens.splice(i, 1);
          } else {
              tween.update();
          }
      }
  }
  }

  let colors = [
      [221, 13, 0],
      [255, 153, 0],
      [48, 143, 255],
      [74, 222, 82],
      [255, 209, 31],
      [255, 82, 245]
  ];


  const playCanvas = document.getElementById('playCanvas');
  let rect = playCanvas.getBoundingClientRect();

  let WINDOW_WIDTH = rect.width;// * devicePixelRatio;
  let WINDOW_HEIGHT = rect.height; // * devicePixelRatio;

  let WINDOW_HALF_WIDTH = WINDOW_WIDTH / 2;
  let WINDOW_HALF_HEIGHT = WINDOW_HEIGHT / 2;


  const ballCanvas = document.createElement('canvas');
  ballCanvas.width = WINDOW_WIDTH;
  ballCanvas.height = WINDOW_HEIGHT;

  const bctx = ballCanvas.getContext('2d');

  playCanvas.width = WINDOW_WIDTH;
  playCanvas.height = WINDOW_HEIGHT;

  const ctx = playCanvas.getContext('2d');

  const GOAL_RADIUS = 40;
  const COLOR = colors[Math.floor(Math.random() * colors.length)];

  let hole = {
      x: WINDOW_HALF_WIDTH,
      y: WINDOW_HALF_HEIGHT,
      r: 0
  }

  let ball = {
      x: WINDOW_HALF_WIDTH + 50,
      y: WINDOW_HALF_HEIGHT + 100,
      r: GOAL_RADIUS
  }

  let mask = true;
  let isAnimating = false;

  let isMousedown = false;
  let isDragging = false;

  let old = {x: 0, y: 0};
  let velocity = {x: 0, y: 0};

  let friction = 0.99;
  let gravity = 0.8;
  let bounce = -0.24;


  window.addEventListener('load', (event) => {
      setup();
  });

  function setup() {

    resize();

        playCanvas.addEventListener("touchmove", (e) => {
            e.preventDefault()
        });

      playCanvas.addEventListener("pointermove", mousemove);
      playCanvas.addEventListener("pointerdown", mousedown);
      playCanvas.addEventListener("pointerup", mouseup);

      window.addEventListener('resize', resize);

      holeIn();

      update();
  }

  function resize() {
    rect = playCanvas.getBoundingClientRect();

    WINDOW_WIDTH = rect.width;// * devicePixelRatio;
    WINDOW_HEIGHT = rect.height; // * devicePixelRatio;

      WINDOW_HALF_WIDTH = WINDOW_WIDTH / 2;
      WINDOW_HALF_HEIGHT = WINDOW_HEIGHT / 2;

      ballCanvas.width = WINDOW_WIDTH;
      ballCanvas.height = WINDOW_HEIGHT;
      playCanvas.width = WINDOW_WIDTH;
      playCanvas.height = WINDOW_HEIGHT;
  }

  function holeIn() {
      hole.x = WINDOW_HALF_WIDTH;
      hole.y = WINDOW_HALF_HEIGHT;
      mask = true;
      Tw.to(hole, {
          r: GOAL_RADIUS + 3, 
          duration: 0.4, 
          delay: 1, 
          ease: 'easeOutQuad'
      });
      Tw.to(hole, {
          r: 0, 
          duration: 0.4, 
          delay: 1.6, 
          ease: 'easeInQuad'
      });

      setTimeout(() => {
          mask = false;
      }, 1600);

      Tw.to(ball, {
          x: WINDOW_HALF_WIDTH, 
          y: WINDOW_HALF_HEIGHT, 
          duration: 0.4, 
          delay: 1.2, 
          ease: 'easeOutQuad'
      });
      Tw.to(ball, {
          y: WINDOW_HEIGHT - GOAL_RADIUS, 
          duration: 1, 
          delay: 1.6, 
          ease: 'bounceOut'
      });

      setTimeout(() => {
          isAnimating = true;
          newHole();
      }, 2600);
  }

  function newHole() {
      hole.x = (WINDOW_HALF_WIDTH / 2) + Math.random() * WINDOW_HALF_WIDTH;
      hole.y = (WINDOW_HALF_HEIGHT / 2) + Math.random() * WINDOW_HALF_HEIGHT;
      
      Tw.to(hole, {
          r: GOAL_RADIUS + 3, 
          duration: 0.4, 
          ease: 'easeOutQuad'
      });
  }

  function mousedown(e) {
      e.preventDefault();

      if (!isAnimating) {
          return;
      }

      isMousedown = true;

      let x = e.offsetX;
      let y = e.offsetY;

      if (x > ball.x - ball.r &&
          x < ball.x + ball.r &&
          y > ball.y - ball.r &&
          y < ball.y + ball.r) {
              isDragging = true;
              old = {x: ball.x, y: ball.y};
          }
  }

  function mouseup(e) {
      e.preventDefault();

      isMousedown = false;
      isDragging = false;
  }

  function mousemove(e) {
        e.preventDefault();

      let x = e.offsetX;
      let y = e.offsetY;

      if (isDragging) {
          ball.x = x;
          ball.y = y;
      }

      if (x > ball.x - ball.r &&
          x < ball.x + ball.r &&
          y > ball.y - ball.r &&
          y < ball.y + ball.r) {
              if (isDragging) {
                  document.body.style.cursor = 'grabbing';
              } else {
                  document.body.style.cursor = 'grab';
              }
          } else {
              document.body.style.cursor = 'default';
          }
  }

  function update() {
      Tw.update();
      animate();
      draw();
      requestAnimationFrame(update);
  }

  function checkHitHole() {
      if (ball.x < hole.x + hole.r &&
          ball.x > hole.x - hole.r &&
          ball.y < hole.y + hole.r &&
          ball.y > hole.y - hole.r) 
      {
          isDragging = false;
          isAnimating = false;
          old = {x: 0, y: 0};
          velocity = {x: 0, y: 0};
          
          Tw.to(ball, {
              x: hole.x, 
              y: hole.y, 
              duration: 0.1, 
              ease: 'easeOutQuad'
          });
          setTimeout(() => {
              mask = true;
              Tw.to(ball, {
                  y: hole.y + 100, 
                  duration: 0.4, 
                  ease: 'easeInQuad'
              });
              Tw.to(hole, {
                  r: 0, 
                  duration: 0.4, 
                  delay: 0.4, 
                  ease: 'easeInQuad'
              });

              setTimeout(() => {
                  holeIn();
              }, 1000)
          }, 300);
      }
  }

  function animate() {

      if (!isAnimating) {
          return;
      }

      checkHitHole();

      let left = 0;
      let right = WINDOW_WIDTH;
      let top = 0;
      let bottom = WINDOW_HEIGHT;

      if (isDragging) {

          if (ball.x + ball.r > right) {
              ball.x = right - ball.r;
          } else if (ball.x - ball.r < left) {
              ball.x = left + ball.r;
          }

          if (ball.y + ball.r > bottom) {
              ball.y = bottom - ball.r;
          } else if (ball.y - ball.r < top) {
              ball.y = top + ball.r;
          }

          velocity.x = ball.x - old.x;
          velocity.y = ball.y - old.y;
          old.x = ball.x;
          old.y = ball.y;
      } else {

          velocity.y += gravity;
          ball.x += velocity.x;
          ball.y += velocity.y;

          if (ball.x + ball.r > right) {
              ball.x = right - ball.r;
              velocity.x *= bounce;
          } else if (ball.x - ball.r < left) {
              ball.x = left + ball.r;
              velocity.x *= bounce;
          }

          if (ball.y + ball.r > bottom) {
              ball.y = bottom - ball.r;
              velocity.y *= bounce;
              velocity.x *= friction;
          } else if (ball.y - ball.r < top) {
              ball.y = top + ball.r;
              velocity.y *= bounce;
          }
      }
  }

  function draw() {

      ctx.clearRect(0, 0, playCanvas.width, playCanvas.height);
      ctx.globalCompositeOperation = 'source-over';

      // draw hole
      ctx.globalAlpha = 0.8;
      ctx.fillStyle = '#333333';
      ctx.beginPath();
      ctx.arc(hole.x, hole.y, hole.r, 0, 2 * Math.PI);
      ctx.fill();
      ctx.globalAlpha = 1;

      drawBall();

      if (mask) {
          ctx.globalCompositeOperation = 'destination-in';

          // draw mask
          ctx.beginPath();
          ctx.arc(hole.x, hole.y, hole.r, 0, 2 * Math.PI);
          ctx.fill();
      }
  }

  function drawBall() {
      bctx.clearRect(0, 0, playCanvas.width, playCanvas.height);

      bctx.fillStyle = 'white';
      bctx.fillRect(0, 0, playCanvas.width, playCanvas.height);

      bctx.globalCompositeOperation = 'source-over';
      drawGradient();

      bctx.globalCompositeOperation = 'destination-in';
      bctx.fillStyle = 'black';

      bctx.beginPath();
      bctx.arc(ball.x, ball.y, ball.r, 0, 2 * Math.PI);
      bctx.fill();

      // shading
      bctx.globalCompositeOperation = 'source-over';

      let grX = ball.x - (ball.r / 4);
      let grY = ball.y - (ball.r / 4);
      var shadingGrd = bctx.createRadialGradient(grX, grY, ball.r / 3, ball.x, ball.y, ball.r * 1.5);
      shadingGrd.addColorStop(0, 'rgba(0, 0, 0, 0)');
      shadingGrd.addColorStop(1, 'rgba(0, 0, 0, 0.2)');
      bctx.fillStyle = shadingGrd;

      bctx.beginPath();
      bctx.arc(ball.x, ball.y, ball.r, 0, 2 * Math.PI);
      bctx.fill();

      ctx.drawImage(ballCanvas, 0, 0);
  }

  function drawGradient() {

      for (let i = 0; i < colors.length; i++) {
          let c = colors[i];
          let colorA = `rgb(${c[0]}, ${c[1]}, ${c[2]})`;
          let colorB = `rgba(${c[0]}, ${c[1]}, ${c[2]}, 0)`;
      
          let x0;
          let y0;
          let x1;
          let y1;

          if (i > 0) {
              let angle = (2 * Math.PI * i) / (colors.length - 1);

              x0 = playCanvas.width / 2 + Math.sin(angle) * (playCanvas.width / 2);
              y0 = playCanvas.height / 2 + Math.cos(angle) * (playCanvas.height / 2);
              x1 = playCanvas.width / 2 + Math.sin(angle) * (playCanvas.width / 2);
              y1 = playCanvas.height / 2 + Math.cos(angle) * (playCanvas.height / 2);
          } else {
              x0 = playCanvas.width / 2;
              y0 = playCanvas.height / 2;
              x1 = playCanvas.width / 2;
              y1 = playCanvas.height / 2;
          }

          var grd = bctx.createRadialGradient(x0, y0, 100, x1, y1, (playCanvas.height / 2));
          grd.addColorStop(0, colorA);
          grd.addColorStop(1, colorB);
      
          bctx.fillStyle = grd;
          bctx.save();

          bctx.fillRect(0, 0, playCanvas.width, playCanvas.height);

          bctx.restore();
      }


      //return grd;
  }
</script>
</body>
</html>
